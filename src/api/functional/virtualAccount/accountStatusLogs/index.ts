import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountAccountStatusLog } from "../../../structures/IVirtualAccountAccountStatusLog";
import { IPageIVirtualAccountAccountStatusLog } from "../../../structures/IPageIVirtualAccountAccountStatusLog";
import { IVirtualAccountAccountStatusLogs } from "../../../structures/IVirtualAccountAccountStatusLogs";

/**
 * Create a new account status change log entry in the
 * `virtual_account_account_status_logs` table.
 *
 * This endpoint creates a new record in the
 * `virtual_account_account_status_logs` table, logging a status transition for
 * a virtual account. All required atomic fields must be validated: virtual
 * account ID, admin ID, old/new status, reason, changed_at timestamp.
 * Referential integrity to both the referenced virtual account and admin is
 * enforced.
 *
 * Security: Only privileged admins can create logs via status changes or manual
 * audit corrections. Uniqueness and auditing constraints are applied. If
 * references are invalid, a 400/404 is returned.
 *
 * This operation is critical for managing compliant and traceable account
 * lifecycle management. Related endpoints: searching, updating, deleting, and
 * viewing details for account status logs.
 *
 * @param props.body Fields for the new account status change log entry.
 * @path /virtualAccount/accountStatusLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Fields for the new account status change log entry. */
    body: IVirtualAccountAccountStatusLog.ICreate;
  };
  export type Body = IVirtualAccountAccountStatusLog.ICreate;
  export type Response = IVirtualAccountAccountStatusLog;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/accountStatusLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/accountStatusLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountAccountStatusLog =>
    typia.random<IVirtualAccountAccountStatusLog>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search virtual account status logs in
 * `virtual_account_account_status_logs` table with paging/filter/sort.
 *
 * This endpoint returns a paginated, filterable list of account status change
 * logs from the `virtual_account_account_status_logs` table. Filters include
 * account ID, admin ID, time windows, or status types. Results are sorted for
 * dashboard/reporting purposes.
 *
 * Security is required: only authorized admins or super admins have access.
 * Filtering and sorting parameters map atomically to columnsâ€”never
 * derived/calculated values. Pagination conventions are followed per admin
 * dashboard requirement.
 *
 * Errors are returned for invalid queries or unauthorized access attempts.
 *
 * This search is vital for audit trailing, reporting, and investigating status
 * transitions or lifecycle events for each virtual account. Related endpoints
 * exist for details, creation, and update.
 *
 * @param props.body Filtering/search/paging information for account status
 *   logs.
 * @path /virtualAccount/accountStatusLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filtering/search/paging information for account status logs. */
    body: IVirtualAccountAccountStatusLog.IRequest;
  };
  export type Body = IVirtualAccountAccountStatusLog.IRequest;
  export type Response = IPageIVirtualAccountAccountStatusLog;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/accountStatusLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/accountStatusLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountAccountStatusLog =>
    typia.random<IPageIVirtualAccountAccountStatusLog>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetch a specific account status log entry by ID from
 * `virtual_account_account_status_logs`.
 *
 * This endpoint fetches a single account status change log by its unique ID
 * from the `virtual_account_account_status_logs` table. Response includes info
 * about the virtual account, old/new statuses, reason for change, admin
 * responsible, and timestamp. Used in audits, dashboard event tracing, and
 * administrator troubleshooting workflows.
 *
 * Security is RBAC-enforced; only privileged users can view the details. If not
 * found, returns 404. Errors follow RESTful semantics, e.g.,
 * unauthorized/forbidden.
 *
 * Related operations cover listing, creation, and updates for account status
 * logs.
 *
 * @param props.id Unique identifier (UUID) of the status log entry.
 * @path /virtualAccount/accountStatusLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier (UUID) of the status log entry. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountAccountStatusLog;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/accountStatusLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/accountStatusLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountAccountStatusLog =>
    typia.random<IVirtualAccountAccountStatusLog>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a virtual_account_account_status_logs row (account status change log).
 *
 * This operation enables authorized administrators to modify a specific account
 * status log record, identified by its unique log ID. The status log records
 * every transition (such as from ACTIVE to EXPIRED or CLOSED) of a virtual
 * account for precise auditing, as required by regulatory and business
 * requirements.
 *
 * The update includes fields like from_status, to_status, reason, admin_id (the
 * actor making the change), and the timestamp changed_at. Admin authorization
 * is enforced through RBAC policies to ensure only permitted updates. Business
 * rules may require that reasons and status values are validated for
 * correctness.
 *
 * Updates are logged to a separate admin audit trail to guarantee
 * non-repudiation and traceability. Attempting to update immutable or
 * already-finalized logs returns an error. Related endpoints include creating a
 * new status log, deleting or fetching existing logs, and querying the list of
 * account status logs for dashboard monitoring.
 *
 * @param props.id Target account status log's ID
 * @param props.body Fields to update for the status log entry.
 * @path /virtualAccount/accountStatusLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target account status log's ID */
    id: string & tags.Format<"uuid">;

    /** Fields to update for the status log entry. */
    body: IVirtualAccountAccountStatusLogs.IUpdate;
  };
  export type Body = IVirtualAccountAccountStatusLogs.IUpdate;
  export type Response = IVirtualAccountAccountStatusLogs;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/accountStatusLogs/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/accountStatusLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountAccountStatusLogs =>
    typia.random<IVirtualAccountAccountStatusLogs>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a virtual_account_account_status_logs row (account status change log).
 *
 * This API allows admin users with appropriate permissions to delete a targeted
 * account status log entry by its unique ID. This log holds the history of each
 * status change in a virtual account's lifecycle. Deleting a status log may be
 * necessary for correcting mistakes, complying with data retention policies, or
 * removing test/demo data from the system.
 *
 * On invocation, the endpoint checks business and regulatory rules about
 * deletability (logs related to finalized/finished accounts may be protected),
 * preserves audit history in virtual_account_admin_activity_logs, and ensures
 * only authorized actors can perform this action. If the log is successfully
 * deleted or soft-deleted, system audit records are updated for traceability.
 * Errors are returned if the log does not exist, is already deleted, or is
 * protected by policy.
 *
 * Related endpoints include updating, querying, and listing account status logs
 * for the dashboard/audit views.
 *
 * @param props.id Target account status log's ID
 * @path /virtualAccount/accountStatusLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target account status log's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountAccountStatusLogs.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/accountStatusLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/accountStatusLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountAccountStatusLogs.IDeleteResult =>
    typia.random<IVirtualAccountAccountStatusLogs.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
