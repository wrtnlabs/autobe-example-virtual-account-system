import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountExternalSystems } from "../../../structures/IVirtualAccountExternalSystems";
import { IVirtualAccountExternalSystem } from "../../../structures/IVirtualAccountExternalSystem";
import { IPageIVirtualAccountExternalSystem } from "../../../structures/IPageIVirtualAccountExternalSystem";

/**
 * Register a new external system configuration for integration
 * (virtual_account_external_systems table).
 *
 * This endpoint allows administrators to register new external system
 * integrations (such as an ERP, e-commerce platform, bank, or payment gateway)
 * into the platform. All required fields—system_type (one of: ERP, MALL, BANK,
 * PG), name, api_base_url, enabled (boolean), and initial timestamp—must be
 * provided. Business rules are applied for system_type/name uniqueness (see
 * @@unique([system_type, name]) in schema), and URLs/config are validated for
 * correctness.
 *
 * Security is enforced (admin/super_admin role only), and the operation is
 * fully audited (triggers creation event in both audit and admin logs).
 * Validation ensures no duplicate system registration and prevents insertion of
 * incomplete or inconsistent data. Related logs and future integration event
 * logs reference this newly created system by ID.
 *
 * API returns the created external system row (excluding any sensitive
 * keys/secrets). Returns HTTP errors for validation failures, duplicates,
 * permission errors, or unexpected issues (400, 409, 401/403, 500,
 * respectively).
 *
 * @param props.body Details for the new external system to register.
 * @path /virtualAccount/externalSystems
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Details for the new external system to register. */
    body: IVirtualAccountExternalSystems.ICreate;
  };
  export type Body = IVirtualAccountExternalSystems.ICreate;
  export type Response = IVirtualAccountExternalSystems;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/externalSystems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/externalSystems";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountExternalSystems =>
    typia.random<IVirtualAccountExternalSystems>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search/filter external systems (virtual_account_external_systems).
 *
 * Fetches a paginated, filterable list of external system definitions (ERP,
 * MALL, BANK/PG) from the virtual_account_external_systems table. Supports
 * filtering by type, name, enabled status, and keyword; implements requirements
 * for integration management and admin dashboard as described in specifications
 * section 4.2/4.3/4.5. Only includes atomic entity data, no joined external
 * results.
 *
 * Admin-only access with strong permission controls. Returns paged list
 * including system details (id, type, name, api_base_url, enabled,
 * created/updated_at). Related endpoints: POST/PUT/DELETE/GET single
 * integration. 403 for unauthorized, 422 for invalid filters.
 *
 * @param props.body Request filter and pagination for external system listing
 * @path /virtualAccount/externalSystems
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Request filter and pagination for external system listing */
    body: IVirtualAccountExternalSystem.IRequest;
  };
  export type Body = IVirtualAccountExternalSystem.IRequest;
  export type Response = IPageIVirtualAccountExternalSystem;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/externalSystems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/externalSystems";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountExternalSystem =>
    typia.random<IPageIVirtualAccountExternalSystem>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a single external system configuration by ID
 * (virtual_account_external_systems table).
 *
 * This API allows administrators to retrieve the complete details for a single
 * external integration system by its ID. The endpoint returns information
 * including the type (ERP, MALL, BANK, PG), the display name, API base URL,
 * enabled status, and timestamps for creation and last update. These details
 * are critical for testing connectivity, verifying credentials, or preparing
 * updates.
 *
 * Security is enforced (only privileged admins or super_admin can access it),
 * and all queries are subject to role-based access control as defined in the
 * requirements. Data returned matches the normalized structure outlined in
 * schema—no sensitive secrets, only non-secret meta and status/config. The
 * endpoint supports integration with other API calls for editing,
 * enabling/disabling, or deleting the system record.
 *
 * If the ID is invalid or the user does not have permission, appropriate error
 * codes are returned (404 for not found, 403 for insufficient privilege, 401
 * for missing authentication, 500 for DB issues).
 *
 * @param props.id UUID of the external system to retrieve.
 * @path /virtualAccount/externalSystems/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of the external system to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountExternalSystems;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/externalSystems/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/externalSystems/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountExternalSystems =>
    typia.random<IVirtualAccountExternalSystems>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update configuration for an external system (virtual_account_external_systems
 * table).
 *
 * This API modifies the settings or properties of an already-registered
 * external system. Admins can edit fields such as the display name, API base
 * URL, enabled status, or update timestamps. Unique constraints (type/name),
 * correct URL format, and boolean flags are enforced by business logic and the
 * underlying database model.
 *
 * Security: Only privileged admin roles may perform this update; audit
 * logs/notices are triggered upon modification for compliance. This operation
 * is used as part of the admin's dashboard integration management. It is not
 * permitted to change primary keys or to insert duplicates; unique constraints
 * are checked before and after the update.
 *
 * Errors are returned for nonexistent IDs (404), invalid payloads or conflicts
 * (400/409), insufficient privileges (403), or unexpected failures (500). The
 * response returns the new state of the external system (with updated fields).
 *
 * @param props.id UUID of the external system to update.
 * @param props.body Update data for the external system configuration.
 * @path /virtualAccount/externalSystems/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of the external system to update. */
    id: string & tags.Format<"uuid">;

    /** Update data for the external system configuration. */
    body: IVirtualAccountExternalSystems.IUpdate;
  };
  export type Body = IVirtualAccountExternalSystems.IUpdate;
  export type Response = IVirtualAccountExternalSystems;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/externalSystems/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/externalSystems/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountExternalSystems =>
    typia.random<IVirtualAccountExternalSystems>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete external system configuration (virtual_account_external_systems
 * table).
 *
 * This API allows an administrator or super_admin to completely remove an
 * external system configuration (ERP, Mall, Bank, PG) by its unique ID. Before
 * deletion, integrity checks are performed: cannot delete a system referenced
 * by existing non-archived integration logs or current sync processes. If
 * allowed, all integration and sync events may be soft-linked (referenced as
 * deleted system) or cascaded as per policy. The operation is fully audited
 * (admin action log, audit record).
 *
 * Security policies: Only privileged admins may delete. Errors are returned for
 * non-existent system, system in use (409), privilege failure (403), or other
 * server errors (500). A successful response is a confirmation of deletion.
 *
 * @param props.id UUID of the external system to delete.
 * @path /virtualAccount/externalSystems/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the external system to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountExternalSystems.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/externalSystems/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/externalSystems/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountExternalSystems.IDeleteResult =>
    typia.random<IVirtualAccountExternalSystems.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
