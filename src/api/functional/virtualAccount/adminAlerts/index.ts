import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { virtual_account_admin_alerts } from "../../../structures/virtual_account_admin_alerts";
import { IVirtualAccountAdminAlerts } from "../../../structures/IVirtualAccountAdminAlerts";
import { IPageIVirtualAccountAdminAlerts } from "../../../structures/IPageIVirtualAccountAdminAlerts";

/**
 * Create a new admin alert (virtual_account_admin_alerts table).
 *
 * This API operation creates a new admin alert record, typically from backend
 * monitoring or detection logic. Examples include mass mismatch detection,
 * external API failures, or security/scaling warnings. The alert will be
 * associated with a specific admin if targeted, or left open/global otherwise.
 * The alert type (such as 'MASS_MISMATCH' or 'SECURITY_WARNING') must be
 * provided, as well as contextual detail in JSON format—this might include
 * involved virtual account IDs, error payloads, or anomaly metrics.
 *
 * The notified_at timestamp records when the alert was generated. The clearable
 * flag controls whether the UI allows an admin to mark this alert as resolved.
 * Alerts are not auto-deleted—clearing status is tracked separately via the
 * cleared_at field.
 *
 * Permissions: Only users with proper admin or super admin role (see RBAC
 * requirements) may invoke this endpoint. All insertions are tracked in the
 * admin activity log. Validation includes schema and actor authentication.
 *
 * On success, returns the full admin alert record. On conflict or error,
 * standardized error responses (422, 403, 409, 500) with details are produced.
 *
 * @param props.body Admin alert event creation info (type, context, target
 *   admin, etc)
 * @path /virtualAccount/adminAlerts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Admin alert event creation info (type, context, target admin, etc) */
    body: virtual_account_admin_alerts.ICreate;
  };
  export type Body = virtual_account_admin_alerts.ICreate;
  export type Response = virtual_account_admin_alerts;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/adminAlerts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/adminAlerts";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): virtual_account_admin_alerts =>
    typia.random<virtual_account_admin_alerts>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List and filter dashboard admin alert records (virtual_account_admin_alerts
 * table).
 *
 * Lists and retrieves all admin alert records (warnings, exceptional events,
 * abnormality signals) from the `virtual_account_admin_alerts` table,
 * supporting search, filter, pagination, and sorting. Allows filtering by alert
 * type, admin, time, and status to troubleshoot and audit dashboard anomalies
 * or urgent notifications. Data model is referenced from Prisma schema—fields
 * include alert type, context JSON, notification/capture times, clearable flag,
 * and so on.
 *
 * Business logic ensures only privileged roles view alerts. Security note:
 * Alerts may contain metadata about system status, errors, and sensitive
 * dashboard events, so output must be appropriately filtered and not leak
 * sensitive system context to unauthorized users. Intended for dashboard
 * abnormal condition displays, external integration error histories, and
 * incident support workflows.
 *
 * @param props.body Search and filter parameters for admin alerts
 *   paging/listing.
 * @path /virtualAccount/adminAlerts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search and filter parameters for admin alerts paging/listing. */
    body: IVirtualAccountAdminAlerts.IRequest;
  };
  export type Body = IVirtualAccountAdminAlerts.IRequest;
  export type Response = IPageIVirtualAccountAdminAlerts;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/adminAlerts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/adminAlerts";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountAdminAlerts =>
    typia.random<IPageIVirtualAccountAdminAlerts>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get one admin alert record (virtual_account_admin_alerts table).
 *
 * Retrieves a specific abnormal event or admin alert record, given its UUID,
 * from the `virtual_account_admin_alerts` table. The full alert record is
 * returned, including alert type, context JSON, status flags, notification and
 * clearance times, and assigned admin (if any). Field-level behavior and
 * meanings are referenced from the Prisma schema docs.
 *
 * Access control ensures only authorized roles may access alert data. Business
 * logic validates UUIDs, handles missing/not authorized/cleared states, and
 * ensures correct visibility of internal details (some context may be redacted
 * for privacy/security). This endpoint is essential for in-depth
 * troubleshooting of dashboard and system alerts in admin UX.
 *
 * @param props.id Admin alert record UUID (primary key of
 *   virtual_account_admin_alerts table).
 * @path /virtualAccount/adminAlerts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /**
     * Admin alert record UUID (primary key of virtual_account_admin_alerts
     * table).
     */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountAdminAlerts;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/adminAlerts/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/adminAlerts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountAdminAlerts => typia.random<IVirtualAccountAdminAlerts>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing admin alert by ID (virtual_account_admin_alerts table).
 *
 * This patch operation allows the client (typically an admin or super admin) to
 * update an admin alert's status by its ID. Permitted modifications include
 * changing the clearable flag, setting the cleared_at timestamp to mark as
 * resolved, and possibly updating the alert context.
 *
 * The operation enforces RBAC: only admins with proper privileges can update
 * alerts. It verifies that the alert exists and is not already cleared if the
 * request is to mark as resolved. All changes are logged in the admin activity
 * log for compliance. Input validation ensures compliance with schema and
 * business rules.
 *
 * Responses: On success, returns the updated alert record. Errors include 404
 * if not found, 409 for state conflict, 403 for permission, or 422 for request
 * validation errors.
 *
 * @param props.id Target admin alert's ID
 * @param props.body Alert update data (e.g., clear status, updated context)
 * @path /virtualAccount/adminAlerts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target admin alert's ID */
    id: string & tags.Format<"uuid">;

    /** Alert update data (e.g., clear status, updated context) */
    body: virtual_account_admin_alerts.IUpdate;
  };
  export type Body = virtual_account_admin_alerts.IUpdate;
  export type Response = virtual_account_admin_alerts;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/adminAlerts/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/adminAlerts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): virtual_account_admin_alerts =>
    typia.random<virtual_account_admin_alerts>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete an admin alert by ID (virtual_account_admin_alerts table).
 *
 * This delete operation marks an admin alert identified by its ID as deleted.
 * Only users with explicit admin or super admin privileges can perform
 * deletions. The operation verifies that the target alert exists, then removes
 * it from the database. Business logic requires logging this action in the
 * admin activity log, and confirmation that the alert is not an active or
 * unresolved system alert before deletion.
 *
 * For compliance/audit, the operation checks associations and logs the deleted
 * alert metadata as needed. Any error (missing ID, already deleted, not found,
 * or RBAC violation) triggers standardized error codes (404, 409, 403, 500).
 *
 * On success, returns a confirmation or the deleted alert data.
 *
 * @param props.id ID of alert to delete
 * @path /virtualAccount/adminAlerts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** ID of alert to delete */
    id: string & tags.Format<"uuid">;
  };
  export type Response = virtual_account_admin_alerts;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/adminAlerts/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/adminAlerts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): virtual_account_admin_alerts =>
    typia.random<virtual_account_admin_alerts>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
