import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountNotification } from "../../../structures/IVirtualAccountNotification";
import { IPageIVirtualAccountNotification } from "../../../structures/IPageIVirtualAccountNotification";

/**
 * Create a new notification event (virtual_account_notifications) for system or
 * manual triggers.
 *
 * Creates a new notification event in the 'virtual_account_notifications'
 * table. Typically used by backend notification processors (upon deposit
 * events, expiration, failed payments, etc) or by admin panel to forcibly
 * trigger manual/customer notifications. Required fields:
 * notification_template_id, notification_channel_id, recipient_id, event_type,
 * status, requested_at; sent_at/delivered_at are later filled in by async
 * processes or admin overrides.
 *
 * Strict validation ensures each field is correct; RBAC controls limit who may
 * create notifications (manual triggers may be restricted to admin roles).
 * Duplicate/invalid data (nonexistent template/channel/recipient) must be
 * handled as per conventions. Upon success, the full event object is returned,
 * suitable for log display/audit needs.
 *
 * @param props.body Creation data for notification event (includes
 *   template/channel/recipient IDs and metadata)
 * @path /virtualAccount/notifications
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Creation data for notification event (includes
     * template/channel/recipient IDs and metadata)
     */
    body: IVirtualAccountNotification.ICreate;
  };
  export type Body = IVirtualAccountNotification.ICreate;
  export type Response = IVirtualAccountNotification;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/notifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/notifications";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountNotification =>
    typia.random<IVirtualAccountNotification>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Search and list notification event records (virtual_account_notifications
 * table) for admin dashboard with advanced filtering.
 *
 * Fetches a paginated, searchable list of all notification event entries as
 * represented in the 'virtual_account_notifications' table. Each notification
 * event documents a particular system alert, user/customer/admin notification,
 * or automated system warning/expiration/incident (such as DEPOSIT_CONFIRMED,
 * DEPOSIT_FAIL, ADMIN_ALERT, etc).
 *
 * The query supports extensive filters/pagination for dashboard needs: by
 * event_type, target recipient (UUID), channel (kakao, email...),
 * notification_template_id, status (SENT, DELIVERED, FAILED), date ranges, and
 * full-text search over status/message fields. Admin users use this endpoint to
 * review outgoing notification performance, troubleshoot failures/non-delivery,
 * and support user/customer service needs.
 *
 * RBAC control ensures only appropriate roles may access notification logs,
 * with special attention to customer privacy and delivery details. The result
 * set may be cross-referenced with channels/templates endpoints for UI
 * presentation. Pagination and performance safeguards are recommended for
 * production use.
 *
 * @param props.body Filtering and pagination/searching options for
 *   notifications.
 * @path /virtualAccount/notifications
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filtering and pagination/searching options for notifications. */
    body: IVirtualAccountNotification.IRequest;
  };
  export type Body = IVirtualAccountNotification.IRequest;
  export type Response = IPageIVirtualAccountNotification;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/notifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/notifications";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountNotification =>
    typia.random<IPageIVirtualAccountNotification>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve single notification event record (virtual_account_notifications) by
 * ID for inspection.
 *
 * Retrieves a single notification event object from the
 * 'virtual_account_notifications' table, identified by UUID. The response
 * details its type, delivery status/timestamps, recipient metadata,
 * template/channel linkage, and status history. Supports in-depth inspection of
 * notification life cycle (sent, delivered, failed, retry...) for audit or
 * customer support.
 *
 * Special care must be taken to restrict access to sensitive delivery info
 * (such as recipient and delivery status). If event is not found, respond with
 * 404. If forbidden by role/RBAC, return 403. Integrates with
 * hierarchical/reference endpoints for notification templates/channels as
 * needed by the dashboard.
 *
 * @param props.id Target notification event UUID to retrieve.
 * @path /virtualAccount/notifications/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target notification event UUID to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountNotification;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/notifications/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/notifications/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountNotification =>
    typia.random<IVirtualAccountNotification>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a notification event record (virtual_account_notifications) -
 * status/classification/context update by admin.
 *
 * Updates a notification event record identified by UUID in
 * 'virtual_account_notifications'. Admin users (with RBAC permission) may
 * change event status, update recipient references, revise template/channel
 * associations, record revised status timestamps, or provide richer
 * troubleshooting/context fields as needed. Mutations are limited to mutable
 * fields (status, sent_at, delivered_at, etc); identity fields are never
 * changed.
 *
 * Every update must trigger audit log entries for compliance. Standard error
 * handling applies (404 for not found, 403 if not authorized, 409 on invalid
 * state transitions). RBAC enforcement restricts sensitive status updates to
 * appropriate roles, e.g., forced DELIVERED or retry scenarios are reserved for
 * system or super-admin.
 *
 * @param props.id Target notification event UUID to update.
 * @param props.body Fields permitted to update on notification event (status,
 *   context, template/channel, times).
 * @path /virtualAccount/notifications/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target notification event UUID to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Fields permitted to update on notification event (status, context,
     * template/channel, times).
     */
    body: IVirtualAccountNotification.IUpdate;
  };
  export type Body = IVirtualAccountNotification.IUpdate;
  export type Response = IVirtualAccountNotification;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/notifications/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/notifications/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountNotification =>
    typia.random<IVirtualAccountNotification>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a notification event record (virtual_account_notifications) by ID with
 * audit and RBAC enforcement.
 *
 * Deletes a notification event record from 'virtual_account_notifications' by
 * UUID. Used rarelyâ€”mostly in compliance with data erasure policies, test data
 * cleanup, or system admin audit fixes. The endpoint is protected by strong
 * RBAC, and full audit logging of deletion actions is required for
 * traceability. Cascade or denial must be handled for dependent log/event rows
 * as per business logic (might restrict deletion if log history exists).
 *
 * Responds with the deleted object or a status/confirmation message. Fails with
 * 404 if not found, 403 if not authorized. All deletions should be idempotent
 * and fully logged for security/compliance.
 *
 * @param props.id Target notification event UUID to delete.
 * @path /virtualAccount/notifications/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target notification event UUID to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountNotification;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/notifications/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/notifications/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountNotification =>
    typia.random<IVirtualAccountNotification>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
