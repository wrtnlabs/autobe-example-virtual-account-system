import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountDepositMatchings } from "../../../structures/IVirtualAccountDepositMatchings";
import { IPageIVirtualAccountDepositMatchings } from "../../../structures/IPageIVirtualAccountDepositMatchings";

/**
 * Insert (create) a new virtual_account_deposit_matchings record.
 *
 * This endpoint is used by the matching system or admin actors to log that a
 * deposit event has been matched to a customer (for successful auto-matching or
 * batch/manual assignment). Required input: deposit ID, acting admin ID,
 * matched customer, matched_at time, method ('AUTOMATIC' or 'MANUAL'), and an
 * audit reason.
 *
 * Validations require that only one matching can be active per deposit,
 * requisite permissions are checked, and business rules for match status
 * progression are enforced. System notifications or downstream workflow
 * triggers (such as error resolution) may occur as side effects. All events are
 * captured for audit compliance. Linked to dashboard, error review, and
 * matching status presentation.
 *
 * Related endpoints: updating, deleting, and querying individual matchings,
 * error linkage, and aggregation for dashboard KPIs.
 *
 * @param props.body Fields for new matching event log.
 * @path /virtualAccount/depositMatchings
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Fields for new matching event log. */
    body: IVirtualAccountDepositMatchings.ICreate;
  };
  export type Body = IVirtualAccountDepositMatchings.ICreate;
  export type Response = IVirtualAccountDepositMatchings;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/depositMatchings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/depositMatchings";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDepositMatchings =>
    typia.random<IVirtualAccountDepositMatchings>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Filter, search, and paginate virtual_account_deposit_matchings (deposit
 * matching logs).
 *
 * This endpoint enables admin or support users to list all deposit matching
 * events with advanced filteringâ€”by status, date, deposit, matched customer,
 * admin, matching method, and custom business filters. Paginated responses
 * support dashboard and downloadable reporting (Excel export). Results provide
 * full audit trail capability, supporting investigation of auto-match errors,
 * admin actions, or customer reconciliation.
 *
 * Key filters include deposit reference, matching times, matching method
 * ('AUTOMATIC', 'MANUAL'), and annotated reasons. Access control is enforced
 * for all queries. Related endpoints: get, update, delete single match records;
 * linked deposit, admin, error logs retrieval. Errors returned for invalid
 * filters or permission issues.
 *
 * @param props.body Search and filter criteria for deposit matchings.
 * @path /virtualAccount/depositMatchings
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search and filter criteria for deposit matchings. */
    body: IVirtualAccountDepositMatchings.IRequest;
  };
  export type Body = IVirtualAccountDepositMatchings.IRequest;
  export type Response = IPageIVirtualAccountDepositMatchings;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/depositMatchings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/depositMatchings";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountDepositMatchings =>
    typia.random<IPageIVirtualAccountDepositMatchings>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetch a single virtual_account_deposit_matchings record (matching event).
 *
 * Enables a privileged user to fetch all fields for a single deposit matching
 * record for review or investigation. Data includes deposit linkage, assigned
 * admin, matched customer, matching time, matching method ('AUTOMATIC',
 * 'MANUAL'), and reason. Supports dashboard auditing, reconciliation reviews,
 * and error diagnosis on manual/automatic matching runs.
 *
 * Strict permission enforcement is required; only authorized auditors, admins,
 * or finance users can access non-anonymized data. Associated endpoints include
 * search for matchings, linked deposit lookup, updating, and deletion.
 * Nonexistent or access-controlled records return appropriate errors.
 *
 * @param props.id Target deposit matching's ID
 * @path /virtualAccount/depositMatchings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target deposit matching's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountDepositMatchings;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/depositMatchings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/depositMatchings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDepositMatchings =>
    typia.random<IVirtualAccountDepositMatchings>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a virtual_account_deposit_matchings record.
 *
 * Allows an authorized admin to change details of a deposit matching record,
 * such as reason, matching method, or involved actors (admin or customer). Use
 * case: annotating match events after investigation, or correcting original
 * assignments from inaccurate automated processing. Only non-finalized
 * (editable) records can be changed; immutable records are protected.
 *
 * All modifications are strictly captured in the admin audit log for
 * transparency and regulatory compliance. Attempts to update protected or
 * non-existent entries return errors. Peer endpoints include fetch, create, and
 * delete matching records, error logs, and reconciliation batch ops.
 *
 * @param props.id Target deposit matching's ID
 * @param props.body Fields to update in the matching event record.
 * @path /virtualAccount/depositMatchings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target deposit matching's ID */
    id: string & tags.Format<"uuid">;

    /** Fields to update in the matching event record. */
    body: IVirtualAccountDepositMatchings.IUpdate;
  };
  export type Body = IVirtualAccountDepositMatchings.IUpdate;
  export type Response = IVirtualAccountDepositMatchings;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/depositMatchings/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/depositMatchings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDepositMatchings =>
    typia.random<IVirtualAccountDepositMatchings>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a virtual_account_deposit_matchings record (matching event).
 *
 * Enables admin users with appropriate audit permissions to delete a deposit
 * matching log entry. Used to correct errors, remove test/demo assignments, or
 * undo inaccurate matching events. On delete, the system enforces strict audit
 * and logging for traceability, and may only allow deletion of non-final or
 * non-essential matches per policy.
 *
 * Attempts to delete protected or linked records return detailed errors. All
 * delete events are written to the audit trail, including actor ID, target
 * record, result, and time. Errors also include permission denials, not found,
 * or immutability rejections. Related endpoints: create, update, list, fetch
 * detail, and backlinked error/deposit event operations.
 *
 * @param props.id Target deposit matching's ID
 * @path /virtualAccount/depositMatchings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target deposit matching's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountDepositMatchings.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/depositMatchings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/depositMatchings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDepositMatchings.IDeleteResult =>
    typia.random<IVirtualAccountDepositMatchings.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
