import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountDeposits } from "../../../structures/IVirtualAccountDeposits";
import { IPageIVirtualAccountDeposits } from "../../../structures/IPageIVirtualAccountDeposits";

/**
 * Create (insert) a new virtual_account_deposits event record (manual deposit
 * entry).
 *
 * This endpoint allows an administrator or system operator to create a deposit
 * event record manually. The new deposit represents an incoming transfer to a
 * virtual account, containing required fields like the linked virtual account,
 * amount received, depositor name, deposited_at datetime, bank reference
 * number, and initial status ('PENDING', 'MATCHED', etc).
 *
 * Business validations include prevention of duplicate reference numbers for a
 * given virtual account, positive amount checks, and permission requirements
 * for manual event creation. Related actions (auto-matching, notification
 * triggers) may be performed after record creation. Full creation events are
 * captured in the audit log with user and event detail.
 *
 * This endpoint is used only in special flows such as manual corrections,
 * integration testing, or deposit reconciliation workflows when normal
 * automated integration is interrupted. Related endpoints include searching
 * deposit events, matching, error record review, and activity log examination.
 *
 * @param props.body Deposit event data to be inserted.
 * @path /virtualAccount/deposits
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Deposit event data to be inserted. */
    body: IVirtualAccountDeposits.ICreate;
  };
  export type Body = IVirtualAccountDeposits.ICreate;
  export type Response = IVirtualAccountDeposits;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/deposits",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/deposits";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDeposits => typia.random<IVirtualAccountDeposits>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Filter, search, and paginate virtual_account_deposits (deposit events).
 *
 * This operation provides a sophisticated search for deposit event records
 * registered in the system. Records in 'virtual_account_deposits' represent all
 * incoming transfers to virtual accounts, with metadata such as account ID,
 * amount, depositor name, timestamp, reference number, and processing status.
 *
 * The dashboard/search request can include numerous criteria: specific account,
 * customer, date range, deposit status (e.g. PENDING, MATCHED, ERROR),
 * reference number, amount range, and more, as well as pagination parameters
 * (page/size) and advanced sorting. Access is restricted to authorized
 * users—typically admins with finance or support roles. Responses are paginated
 * result lists with accompanying metadata for further filtering or Excel
 * export.
 *
 * This operation is linked to matching review, error investigation, and batch
 * reconciliation workflows, as well as notification/alert triggers for deposit
 * processing states. Business rules and validation are applied to all search
 * criteria, and error responses are returned for invalid queries or permission
 * faults.
 *
 * @param props.body Search and filter criteria for deposit events.
 * @path /virtualAccount/deposits
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search and filter criteria for deposit events. */
    body: IVirtualAccountDeposits.IRequest;
  };
  export type Body = IVirtualAccountDeposits.IRequest;
  export type Response = IPageIVirtualAccountDeposits;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/deposits",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/deposits";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountDeposits =>
    typia.random<IPageIVirtualAccountDeposits>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetch a single virtual_account_deposits record (deposit event).
 *
 * This operation returns all available information about a specific deposit
 * record, identified by UUID. It fetches metadata including the linked virtual
 * account, event timestamp, incoming amount, depositor details, bank reference,
 * processing status, and timestamps (created/updated).
 *
 * Access is typically restricted to authorized admin, finance, or customer
 * support personnel. Usage scenarios include resolving disputes, viewing
 * historical records for audit, or performing manual reconciliation, especially
 * where automatic matching failed or additional notes must be attached. Related
 * operations are deposit search/list, updating deposit data, soft/hard deletion
 * for cleanup, or triggering manual matching/error investigations.
 *
 * @param props.id Target deposit event's ID
 * @path /virtualAccount/deposits/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target deposit event's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountDeposits;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/deposits/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/deposits/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDeposits => typia.random<IVirtualAccountDeposits>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a virtual_account_deposits event record.
 *
 * Provides the ability for an admin or support role to update a deposit event
 * record to correct data, annotate with additional information, or move it
 * through the processing workflow. Updateable fields are typically amount,
 * depositor name, deposited time, reference number, and status. Updates must
 * not violate business rules such as duplicate references or illegal negative
 * amounts. API checks RBAC permissions before applying changes.
 *
 * Every update event is tracked in the admin action/audit log for compliance
 * with financial regulations. No updates are allowed to immutable or finalized
 * deposit entries. Access is limited to authorized roles (audit, finance,
 * support). Errors occur for nonexistent records or forbidden updates. Related
 * endpoints: fetch, create, delete deposit, matching/error subflows.
 *
 * @param props.id Target deposit event's ID
 * @param props.body Editable fields for the deposit event update.
 * @path /virtualAccount/deposits/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target deposit event's ID */
    id: string & tags.Format<"uuid">;

    /** Editable fields for the deposit event update. */
    body: IVirtualAccountDeposits.IUpdate;
  };
  export type Body = IVirtualAccountDeposits.IUpdate;
  export type Response = IVirtualAccountDeposits;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/deposits/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/deposits/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDeposits => typia.random<IVirtualAccountDeposits>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a virtual_account_deposits event record.
 *
 * Allows a privileged admin to remove (or soft-delete) a deposit event record
 * by UUID. Used in scenarios where a deposit was entered in error (manual/test
 * records), or regulatory/data retention policies require cleanup.
 *
 * Deletes may be restricted by business logic—such as not allowing deletion of
 * completed/finalized deposits. Action is strictly permission-controlled
 * (audit/compliance), and every delete is tracked in the admin audit log for
 * later inspection. Errors are returned for not found or protected records.
 *
 * Related endpoints include creation, updating, searching, and matching of
 * deposit events, as well as reconciliation and notification audit features.
 *
 * @param props.id Target deposit event's ID
 * @path /virtualAccount/deposits/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target deposit event's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountDeposits.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/deposits/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/deposits/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDeposits.IDeleteResult =>
    typia.random<IVirtualAccountDeposits.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
