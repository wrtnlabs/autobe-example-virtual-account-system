import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountBank } from "../../../structures/IVirtualAccountBank";
import { IPageIVirtualAccountBank } from "../../../structures/IPageIVirtualAccountBank";

/**
 * Creates a new bank record in virtual_account_banks.
 *
 * This endpoint allows authorized admins to add a new bank to the master table,
 * virtual_account_banks, by posting the required bank metadata in the request
 * body. The payload requires all necessary fields as per the Prisma schema:
 * name, code, logo_url (optional), and other audit data as per business rules.
 *
 * Uniqueness of bank code is enforced, as are field lengths and data
 * validation. If a bank entry with the same code already exists, an error (409)
 * is returned. Successful inserts are audit-logged.
 *
 * Only users with admin/superadmin privileges can use this endpoint (RBAC
 * required). Related endpoints: PATCH (list/search banks), GET (detail), PUT
 * (update), DELETE (remove).
 *
 * @param props.body New bank details to create (name, code, logo_url, etc).
 * @path /virtualAccount/banks
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** New bank details to create (name, code, logo_url, etc). */
    body: IVirtualAccountBank.ICreate;
  };
  export type Body = IVirtualAccountBank.ICreate;
  export type Response = IVirtualAccountBank;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/banks",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/banks";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountBank => typia.random<IVirtualAccountBank>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Returns a paginated/filterable list of available banks for virtual account
 * issuance.
 *
 * This operation retrieves a paginated list of banks available for virtual
 * account issuance, supporting filtering and paging via PATCH request body
 * consistent with REST API best practices. The entity (virtual_account_banks
 * table) manages the master registry of banks, as explained in the Prisma
 * schema.
 *
 * The request body can specify search criteria such as name, code, and sort
 * order. The logic supports administrator dashboard use cases for managing,
 * reviewing, and filtering available banks. Only admin or superadmin users may
 * access this endpoint. All access and filter actions are audit-logged for
 * compliance.
 *
 * Related endpoints are POST (add new bank), GET (detail), PUT (update), and
 * DELETE (remove) for the same entity. Business logic: banks in use by active
 * virtual accounts may not be deleted (referential integrity enforced).
 *
 * @param props.body Optional filters, sort order, and paging config for the
 *   bank list.
 * @path /virtualAccount/banks
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Optional filters, sort order, and paging config for the bank list. */
    body: IVirtualAccountBank.IRequest;
  };
  export type Body = IVirtualAccountBank.IRequest;
  export type Response = IPageIVirtualAccountBank;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/banks",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/banks";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountBank => typia.random<IPageIVirtualAccountBank>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves detailed info on a specific bank from virtual_account_banks by ID.
 *
 * This operation retrieves full information on a specific bank from the
 * virtual_account_banks entity by its unique ID. The target is the master table
 * row referenced by virtual accounts during issuance.
 *
 * The endpoint supports both dashboard drill-down for bank management and
 * direct configuration checks during onboarding or troubleshooting. The
 * operation is RBAC-protected, audit-logged, and returns 404 if the record does
 * not exist or 403 if the user lacks privileges. Details returned include all
 * available metadata: name, code, logo_url, timestamps, etc. Related endpoints:
 * PATCH (list), POST (add), PUT (edit), DELETE (remove) on banks. Error
 * handling includes missing/invalid ID and privilege enforcement as per
 * security policy.
 *
 * @param props.id Unique identifier for the bank record to fetch.
 * @path /virtualAccount/banks/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier for the bank record to fetch. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountBank;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/banks/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/banks/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountBank => typia.random<IVirtualAccountBank>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates an existing bank in the virtual_account_banks table by ID.
 *
 * This endpoint enables authorized admin users to update fields in a bank
 * entity identified by its ID in the virtual_account_banks table. The payload
 * can specify any permitted bank fields (e.g., name, logo_url, status), as
 * defined in the Prisma schema.
 *
 * Only allowed/valid fields can be set. Uniqueness on 'code' is preserved
 * (cannot change to existing code). All edit attempts, successful or failed,
 * are fully audit-logged. The user must have admin or superadmin role.
 *
 * Related endpoints: PATCH (list/search), GET (detail), POST (create new),
 * DELETE (remove) for this entity. Errors are returned on invalid data,
 * constraint failure, not found, or RBAC denial.
 *
 * @param props.id Bank entity unique identifier to update.
 * @param props.body Fields to update for the bank entry.
 * @path /virtualAccount/banks/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Bank entity unique identifier to update. */
    id: string & tags.Format<"uuid">;

    /** Fields to update for the bank entry. */
    body: IVirtualAccountBank.IUpdate;
  };
  export type Body = IVirtualAccountBank.IUpdate;
  export type Response = IVirtualAccountBank;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/banks/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/banks/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountBank => typia.random<IVirtualAccountBank>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Deletes a bank record in virtual_account_banks by ID (RBAC-protected).
 *
 * This operation deletes a bank entry from the virtual_account_banks master
 * table using the 'id' path parameter. As per the ERD/schema, a bank may only
 * be deleted if it is not referenced by any active virtual accounts, which is
 * enforced before removal. Any attempt to delete an in-use bank returns an
 * integrity error.
 *
 * This endpoint is restricted to admin and superadmin roles. All deletion
 * attempts are audit-logged for compliance. Related operations:
 * PATCH/GET/POST/PUT for banks. Returns 204 on success, 409 on reference error,
 * or 404 if the bank record is not found.
 *
 * @param props.id Bank record unique identifier to delete.
 * @path /virtualAccount/banks/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Bank record unique identifier to delete. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/banks/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/banks/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
