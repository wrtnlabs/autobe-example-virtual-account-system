import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountHmacKeys } from "../../../structures/IVirtualAccountHmacKeys";
import { IPageIVirtualAccountHmacKeys } from "../../../structures/IPageIVirtualAccountHmacKeys";

/**
 * Register a new HMAC key meta entry in 'virtual_account_hmac_keys'.
 *
 * Creates a new HMAC key registry entry in 'virtual_account_hmac_keys'.
 *
 * Used by security/integration admins to onboard a new external API integration
 * credential. All required field data provided in request body:
 * external_system, key_label, enabled, expiration dates, etc. No cryptographic
 * secrets handled by this API (secrets managed in runtime/vault). PK/label
 * uniqueness enforced. Full privilege and admin role checks apply. All events
 * and changes are recorded for IT compliance (per requirements & 보안 정책).
 *
 * On duplicate label/external_system, returns 409. Returns created record's
 * metadata on success.
 *
 * @param props.body Meta for creating an HMAC key record (external_system,
 *   key_label, status, etc.).
 * @path /virtualAccount/hmacKeys
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Meta for creating an HMAC key record (external_system, key_label,
     * status, etc.).
     */
    body: IVirtualAccountHmacKeys.ICreate;
  };
  export type Body = IVirtualAccountHmacKeys.ICreate;
  export type Response = IVirtualAccountHmacKeys;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/hmacKeys",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/hmacKeys";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountHmacKeys => typia.random<IVirtualAccountHmacKeys>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search HMAC key registry entries from 'virtual_account_hmac_keys'.
 *
 * This endpoint provides paged and filterable listing for HMAC credential
 * metadata from 'virtual_account_hmac_keys'.
 *
 * Core use: dashboard/key registry management, key lifecycle tracking, audit,
 * and security dashboard. Filtering by external_system and enabled state is
 * supported, as is pagination and sort. No secret values stored or returned
 * here per security requirements—only meta and status. Only visible to
 * platform/system admins. Unauthorized access returns 403. Paged result for
 * high-volume registries.
 *
 * @param props.body Query options for HMAC key registry (external_system,
 *   key_label, enabled, page/size, sort).
 * @path /virtualAccount/hmacKeys
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Query options for HMAC key registry (external_system, key_label,
     * enabled, page/size, sort).
     */
    body: IVirtualAccountHmacKeys.IRequest;
  };
  export type Body = IVirtualAccountHmacKeys.IRequest;
  export type Response = IPageIVirtualAccountHmacKeys;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/hmacKeys",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/hmacKeys";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountHmacKeys =>
    typia.random<IPageIVirtualAccountHmacKeys>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get metadata/details for a single HMAC key from 'virtual_account_hmac_keys'.
 *
 * Fetches the metadata for a single HMAC API key from
 * 'virtual_account_hmac_keys'.
 *
 * Used by key registry explorers, admin portal, or integration automation
 * editors. Reveals meta fields, status, usage info only; never returns
 * cryptographic secret. Relies on Prisma PK for selection; RBAC-permissioned
 * admin only. Returns 404 if not found, or 403 for unauthorized. Full event is
 * audit-logged. No update or secret revealed.
 *
 * Supports only PK query (no composite key/lookup by label).
 *
 * @param props.id UUID PK of the HMAC key to retrieve.
 * @path /virtualAccount/hmacKeys/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID PK of the HMAC key to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountHmacKeys;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/hmacKeys/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/hmacKeys/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountHmacKeys => typia.random<IVirtualAccountHmacKeys>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update metadata for a single HMAC key in 'virtual_account_hmac_keys'.
 *
 * Updates an HMAC key registry record's metadata identified by PK UUID.
 *
 * Used by security/integration admins to update status (enable/disable), rotate
 * timestamp, or label for a key. PK uniqueness enforced. Changing meta may
 * affect integration/automation—business logic should prevent accidental
 * disabling of in-use keys. All changes are audit-logged. RBAC enforced
 * strictly for write access.
 *
 * No secret key material is ever returned or accepted. Fully follows admin
 * security and compliance policy. Fails with 404 if key not found. Returns
 * updated record's metadata on success.
 *
 * @param props.id UUID PK of HMAC key to update.
 * @param props.body Fields for updating HMAC key metadata (status/label/etc,
 *   never secrets).
 * @path /virtualAccount/hmacKeys/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID PK of HMAC key to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Fields for updating HMAC key metadata (status/label/etc, never
     * secrets).
     */
    body: IVirtualAccountHmacKeys.IUpdate;
  };
  export type Body = IVirtualAccountHmacKeys.IUpdate;
  export type Response = IVirtualAccountHmacKeys;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/hmacKeys/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/hmacKeys/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountHmacKeys => typia.random<IVirtualAccountHmacKeys>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete metadata for HMAC key by PK from 'virtual_account_hmac_keys'.
 *
 * Deletes a metadata row for an HMAC credential key from
 * 'virtual_account_hmac_keys' table, by PK.
 *
 * Primary use: revoke, remove, or prune expired or unused external integration
 * credentials. Never deletes or reveals secrets. Operation is irreversible and
 * events are always audit-logged for compliance. Only RBAC-enforced admins can
 * execute; errors returned for missing/not found keys (404), or privilege
 * denied (403).
 *
 * Successful call returns empty or basic result. External resource cleanup is
 * handled by separate process (if needed).
 *
 * @param props.id PK UUID of HMAC key to delete.
 * @path /virtualAccount/hmacKeys/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** PK UUID of HMAC key to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountHmacKeys.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/hmacKeys/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/hmacKeys/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountHmacKeys.IDeleteResult =>
    typia.random<IVirtualAccountHmacKeys.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
