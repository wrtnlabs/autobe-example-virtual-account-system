import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { virtual_account_materialized_stats } from "../../../structures/virtual_account_materialized_stats";
import { IVirtualAccountMaterializedStats } from "../../../structures/IVirtualAccountMaterializedStats";
import { IPageIVirtualAccountMaterializedStats } from "../../../structures/IPageIVirtualAccountMaterializedStats";

/**
 * Create a new virtual_account_materialized_stats record (stat snapshot).
 *
 * Creates a new materialized statistics snapshot record in the system for
 * reporting or analytics purposes.
 *
 * This endpoint is typically used by system automation (e.g., ETL batch job,
 * scheduled stats calculation), or by super administrators, to insert the
 * latest stat value snapshot after bulk processing. It records the stat key,
 * value (as string), and the as_of timestamp, making it available for fast
 * dashboard rendering and reporting. Creation events are audit-logged, and only
 * highly privileged users or system accounts should call this operation. On
 * success, returns the complete created materialized stats row.
 *
 * @param props.body Materialized stat entry data to create (key, value,
 *   timestamp).
 * @path /virtualAccount/materializedStats
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Materialized stat entry data to create (key, value, timestamp). */
    body: virtual_account_materialized_stats.ICreate;
  };
  export type Body = virtual_account_materialized_stats.ICreate;
  export type Response = virtual_account_materialized_stats;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/materializedStats",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/materializedStats";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): virtual_account_materialized_stats =>
    typia.random<virtual_account_materialized_stats>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get paged list of dashboard/reporting stats from
 * 'virtual_account_materialized_stats'.
 *
 * This endpoint exposes performance and dashboard stats as cached/denormalized
 * records from 'virtual_account_materialized_stats'.
 *
 * Supports query, pagination, filter by stat_key/as_of, etc., for
 * admin/dashboard context (never writable by API). Data is used to rapidly
 * populate graphs, tables, and KPIs for UI, management consoles, and scheduled
 * analytics jobs. Read-only for all users. RBAC/permission-controlled.
 * Unauthenticated requests return 403. If query is empty, returns current
 * paginated default dashboard.
 *
 * Never reveals business-sensitive raw detailsâ€”only aggregates and dashboard
 * values per best practice. Errors use OpenAPI error semantics (never reveals
 * table or query structure).
 *
 * @param props.body Query params for dashboard stats (stat_key, as_of,
 *   page/size, sort).
 * @path /virtualAccount/materializedStats
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Query params for dashboard stats (stat_key, as_of, page/size, sort). */
    body: IVirtualAccountMaterializedStats.IRequest;
  };
  export type Body = IVirtualAccountMaterializedStats.IRequest;
  export type Response = IPageIVirtualAccountMaterializedStats;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/materializedStats",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/materializedStats";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountMaterializedStats =>
    typia.random<IPageIVirtualAccountMaterializedStats>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get details of a single virtual_account_materialized_stats record by ID.
 *
 * Retrieves the details of a specific materialized statistics record using its
 * unique ID.
 *
 * This endpoint provides direct access to the denormalized, materialized stat
 * snapshot row in the database. It is primarily used for dashboard analytics,
 * admin audits, or system health checks by referencing the stat ID from
 * performance charts, alerts, or reporting drilldowns. This ensures that
 * details of the stat, such as the metric key (e.g., 'active_accounts',
 * 'fail_deposit_count'), value, and snapshot timestamp, can be reviewed or
 * verified directly by administrators.
 *
 * Only users with appropriate read permissions to system metrics are allowed
 * access; sensitive or performance stats may require additional security
 * controls. If the stat ID does not exist or has expired/been purged, a 404 Not
 * Found error will be returned. Referenced by admin dashboard for stat
 * drill-downs; no modification of the stat occurs with this endpoint.
 *
 * @param props.id Unique identifier for the materialized stats record to fetch.
 * @path /virtualAccount/materializedStats/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier for the materialized stats record to fetch. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = virtual_account_materialized_stats;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/materializedStats/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/materializedStats/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): virtual_account_materialized_stats =>
    typia.random<virtual_account_materialized_stats>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing virtual_account_materialized_stats record by ID.
 *
 * Updates a materialized statistics record with the specified ID in the system.
 * Only the stat_key, stat_value, or as_of timestamp can be changed.
 *
 * This endpoint is restricted to highly privileged administrative and system
 * automation contexts. It allows correcting a mistake or rolling back reporting
 * metrics in exceptional situations. All update operations are fully
 * audit-logged to meet compliance and accuracy requirements. If the record does
 * not exist, a 404 Not Found error will result. Normally, dashboard/stat usage
 * does not require updates except for manual corrections.
 *
 * @param props.id ID of the materialized stats record to update.
 * @param props.body New stat values to update (stat_key, stat_value, as_of)
 * @path /virtualAccount/materializedStats/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** ID of the materialized stats record to update. */
    id: string & tags.Format<"uuid">;

    /** New stat values to update (stat_key, stat_value, as_of) */
    body: virtual_account_materialized_stats.IUpdate;
  };
  export type Body = virtual_account_materialized_stats.IUpdate;
  export type Response = virtual_account_materialized_stats;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/materializedStats/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/materializedStats/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): virtual_account_materialized_stats =>
    typia.random<virtual_account_materialized_stats>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a virtual_account_materialized_stats record by ID (system/admin use
 * only).
 *
 * Deletes an existing materialized statistics row from the stats snapshots
 * table by its unique ID.
 *
 * This endpoint is called only by privileged system automation or
 * administrators (e.g., when cleaning up old/retired stat keys, or if
 * stale/corrupt data needs to be forcibly removed). Access is strictly
 * permissioned, and all deletion events are audit-logged. If the record does
 * not exist or is protected as an immutable snapshot, a 404 or 403 error will
 * be returned as appropriate. Used for rare dashboard/performance maintenance
 * cases only.
 *
 * @param props.id ID of the materialized stats record to delete.
 * @path /virtualAccount/materializedStats/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** ID of the materialized stats record to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = virtual_account_materialized_stats.IDeleteResponse;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/materializedStats/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/materializedStats/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): virtual_account_materialized_stats.IDeleteResponse =>
    typia.random<virtual_account_materialized_stats.IDeleteResponse>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
