import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountDashboardSettings } from "../../../structures/IVirtualAccountDashboardSettings";
import { IPageIVirtualAccountDashboardSettings } from "../../../structures/IPageIVirtualAccountDashboardSettings";

/**
 * Create a new Admin dashboard settings record
 * (virtual_account_dashboard_settings table).
 *
 * This endpoint allows the creation of a dashboard configuration/settings
 * record for a specific administrator. The payload includes the target admin
 * UUID and a validated JSON settings blob, which encodes preferences like
 * default filters, column selections, and notification rules. The system sets
 * creation and update timestamps atomically in the database.
 *
 * Validation: Only one dashboard settings record per admin should exist (see
 * unique constraint in Prisma schema); attempts to create duplicates must
 * return a 409 error. Only users with the correct privilege may create or
 * initialize dashboard settings.
 *
 * Audit requirements include logging who performed the creation, linking the
 * record to the admin, and ensuring that no sensitive or system-internal config
 * is injectible from the client. Errors are returned if invalid admin IDs or
 * malformed JSON are provided.
 *
 * All fields correspond to those described in the Prisma schema for
 * 'virtual_account_dashboard_settings'.
 *
 * @param props.body Admin UUID and initial dashboard settings JSON blob.
 * @path /virtualAccount/dashboardSettings
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Admin UUID and initial dashboard settings JSON blob. */
    body: IVirtualAccountDashboardSettings.ICreate;
  };
  export type Body = IVirtualAccountDashboardSettings.ICreate;
  export type Response = IVirtualAccountDashboardSettings;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/dashboardSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/dashboardSettings";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDashboardSettings =>
    typia.random<IVirtualAccountDashboardSettings>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List and filter all Admin dashboard settings
 * (virtual_account_dashboard_settings table).
 *
 * This endpoint supports listing and filtering all administrative dashboard
 * settings entries in the virtual account system. It directly queries the
 * `virtual_account_dashboard_settings` table, as described in the Prisma
 * schema, which contains JSON settings, timestamps, and the associated admin.
 * Access control and filtering should be enforced so only permitted roles can
 * search, and fields such as filter state, preferred columns, and notification
 * preferences are returned as part of the "settings_json" field.
 *
 * Security considerations: Only admins or super-admins with dashboard
 * management permissions should access this endpoint. Returned data should not
 * leak sensitive configuration elements. Input validation must allow filtering
 * by admin, by creation/update date ranges, and enable full pagination and
 * sorting (for export/history auditing use-cases).
 *
 * Examples of business logic include returning only settings for active admins,
 * restricting deleted or test accounts, and ensuring the settings reflect real
 * dashboard use.
 *
 * This operation also provides tracing for when settings were last updated,
 * referencing `created_at` and `updated_at` as indexed in the schema. Error
 * handling should provide consistent pagination errors and filter validation
 * messages as per OpenAPI best practices.
 *
 * @param props.body Parameters for searching, filtering, and paginating admin
 *   dashboard settings records.
 * @path /virtualAccount/dashboardSettings
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Parameters for searching, filtering, and paginating admin dashboard
     * settings records.
     */
    body: IVirtualAccountDashboardSettings.IRequest;
  };
  export type Body = IVirtualAccountDashboardSettings.IRequest;
  export type Response = IPageIVirtualAccountDashboardSettings;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/dashboardSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/dashboardSettings";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountDashboardSettings =>
    typia.random<IPageIVirtualAccountDashboardSettings>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get one Admin dashboard setting record (virtual_account_dashboard_settings
 * table).
 *
 * Given a unique dashboard setting id, this endpoint returns the full record
 * from the `virtual_account_dashboard_settings` table. It includes all
 * personalized admin dashboard preferences, stored as a JSON blob, along with
 * creation and update timestamps.
 *
 * The operation ensures only permitted roles (e.g., the owning admin,
 * superadmin, or users with audit/view privileges) can access the data, and
 * does not expose sensitive or internal-only options included in the settings
 * blob.
 *
 * Business logic includes validating the id, handling non-existent or
 * unauthorized-access attempts, and logging the access for audit purposes. This
 * facilitates help desk operations, settings troubleshooting, and security
 * audits.
 *
 * References Prisma schema table docs for field meanings and normalization,
 * ensuring no denormalized configuration is leaked.
 *
 * @param props.id Admin dashboard settings record UUID (primary key of
 *   virtual_account_dashboard_settings).
 * @path /virtualAccount/dashboardSettings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /**
     * Admin dashboard settings record UUID (primary key of
     * virtual_account_dashboard_settings).
     */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountDashboardSettings;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/dashboardSettings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/dashboardSettings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDashboardSettings =>
    typia.random<IVirtualAccountDashboardSettings>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing Admin dashboard settings record
 * (virtual_account_dashboard_settings table).
 *
 * This endpoint allows for updating the UI/dashboard personalization for a
 * specific admin by modifying the existing record in the
 * `virtual_account_dashboard_settings` table, identified by UUID. The payload
 * includes the up-to-date JSON settings, which may change view filters,
 * notification preferences, columns, etc.
 *
 * Access control must ensure that only the owner or properly privileged admin
 * can update settings. All fields must be validated according to the schema
 * (JSON blob, timestamps, and admin linkage), and an error should be returned
 * for non-existent records.
 *
 * The relationship and singularity are enforced: only one settings record per
 * admin. Update locking and last-write-wins strategy should be considered to
 * avoid concurrent modification problems. The endpoint updates the `updated_at`
 * timestamp accordingly.
 *
 * Logs are written as per compliance requirements for audit/tracing.
 *
 * @param props.id Admin dashboard settings record UUID (primary key).
 * @param props.body Updated dashboard settings JSON blob and relevant fields.
 * @path /virtualAccount/dashboardSettings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Admin dashboard settings record UUID (primary key). */
    id: string & tags.Format<"uuid">;

    /** Updated dashboard settings JSON blob and relevant fields. */
    body: IVirtualAccountDashboardSettings.IUpdate;
  };
  export type Body = IVirtualAccountDashboardSettings.IUpdate;
  export type Response = IVirtualAccountDashboardSettings;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/dashboardSettings/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/dashboardSettings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDashboardSettings =>
    typia.random<IVirtualAccountDashboardSettings>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete an Admin dashboard settings record (virtual_account_dashboard_settings
 * table).
 *
 * This endpoint deletes the specified dashboard settings record from the
 * database, fully removing dashboard personalization for the targeted admin. It
 * validates that the resource exists and the requester is authorized (owner,
 * superadmin, or privileged admin).
 *
 * Audit logging/tracing must be performed as per compliance.
 * Nonexistent/unauthorized-id errors must return 404/403, not accidentally
 * expose existence/absence. On success, a confirmation or deleted record info
 * is returned, but personalization is irrecoverable thereafter. This operation
 * is referenced by the Prisma schema docs for full table and column meaning.
 *
 * @param props.id UUID (primary key) of the admin dashboard settings record to
 *   delete.
 * @path /virtualAccount/dashboardSettings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID (primary key) of the admin dashboard settings record to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountDashboardSettings.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/dashboardSettings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/dashboardSettings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountDashboardSettings.IDeleteResult =>
    typia.random<IVirtualAccountDashboardSettings.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
