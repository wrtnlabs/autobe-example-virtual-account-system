import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountExcelExports } from "../../../structures/IVirtualAccountExcelExports";
import { IPageIVirtualAccountExcelExports } from "../../../structures/IPageIVirtualAccountExcelExports";

/**
 * Create a new admin Excel export event log (virtual_account_excel_exports
 * table).
 *
 * Allows the system or an admin user to record (log) a new Excel export event
 * by inserting a new event log into the `virtual_account_excel_exports` table.
 * The payload includes admin ID, export type, filters, timestamp, file
 * location, and outcome. Ensures that only correct roles can create export logs
 * (e.g., after an actual export/download occurs). On success, returns the
 * created log entry.
 *
 * Data fields are validated and correspond to Prisma schema for this table—no
 * file content is stored, only file path and metadata. Errors occur for invalid
 * types/fields, duplicated or invalid events, or unauthorized admin attempts.
 * References documentation and schema field meanings for API alignment.
 *
 * @param props.body Admin ID, export type, filter JSON, file location, and
 *   outcome.
 * @path /virtualAccount/excelExports
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Admin ID, export type, filter JSON, file location, and outcome. */
    body: IVirtualAccountExcelExports.ICreate;
  };
  export type Body = IVirtualAccountExcelExports.ICreate;
  export type Response = IVirtualAccountExcelExports;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/excelExports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/excelExports";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountExcelExports =>
    typia.random<IVirtualAccountExcelExports>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List and filter admin Excel export logs (virtual_account_excel_exports
 * table).
 *
 * Lists and filters all admin-triggered Excel export events by querying the
 * `virtual_account_excel_exports` table according to provided
 * search/filter/pagination parameters. Allows filtering exports by admin,
 * period, type, and success status, for visibility on data exports in the
 * virtual account system. Supports pagination, sorting, and detailed filter
 * conditions for export event history.
 *
 * Security: Only privileged roles (e.g., superadmin or export-managers) should
 * access this endpoint. Audit considerations for viewing logs should apply, and
 * only non-sensitive export metadata is returned (does NOT include file
 * contents, only file path URI and meta; see Prisma schema).
 *
 * Request and response structure aligns fully with OpenAPI, referencing the
 * schema's field docs for filterability, traceability, and normalization. Hard
 * errors (e.g., invalid filters) return validation errors. Intended for use in
 * export activity audit pages and support.
 *
 * @param props.body Filtering and pagination parameters for Excel export log
 *   listing.
 * @path /virtualAccount/excelExports
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filtering and pagination parameters for Excel export log listing. */
    body: IVirtualAccountExcelExports.IRequest;
  };
  export type Body = IVirtualAccountExcelExports.IRequest;
  export type Response = IPageIVirtualAccountExcelExports;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/excelExports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/excelExports";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountExcelExports =>
    typia.random<IPageIVirtualAccountExcelExports>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get one admin Excel export log record (virtual_account_excel_exports table).
 *
 * Given a unique Excel export log identifier (UUID), this endpoint returns the
 * entire Excel export metadata record from the `virtual_account_excel_exports`
 * table, including admin info, export type, filter state, timestamps, outcome,
 * and file path. DOES NOT return file content (only file URI and meta, as per
 * Prisma schema normalization).
 *
 * Access is controlled by role-based permissions—requester must be the
 * exporting admin, or a privileged (superadmin) user. Input validation ensures
 * proper UUID structure, and 404 is returned if not found or not permitted.
 *
 * Record structure and all fields correspond exactly to documentation in the
 * Prisma schema. Used in support/export audit screens.
 *
 * @param props.id Excel export event log UUID (primary key of
 *   virtual_account_excel_exports).
 * @path /virtualAccount/excelExports/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /**
     * Excel export event log UUID (primary key of
     * virtual_account_excel_exports).
     */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountExcelExports;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/excelExports/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/excelExports/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountExcelExports =>
    typia.random<IVirtualAccountExcelExports>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing admin Excel export log entry
 * (virtual_account_excel_exports table).
 *
 * Updates a specific Excel export log in the `virtual_account_excel_exports`
 * table (identified by UUID) with new metadata, such as status, file path
 * correction, timestamps, or related filter info. Normal business flow: invoked
 * after a background export task completes and file path is finalized.
 *
 * Only privileged roles (the exporting admin, or superadmin) should be able to
 * update this log. Request payload must conform to the correct update schema,
 * as described in Prisma docs. Business logic ensures that file content is not
 * injected or stored—only path and meta fields may be updated. History and
 * audit log of updates must be maintained outside this core event (for
 * compliance).
 *
 * Record is returned as per OpenAPI response-body conventions, or 404 if no
 * record found/authorized.
 *
 * @param props.id Excel export event log UUID (primary key of
 *   virtual_account_excel_exports).
 * @param props.body Fields to update in the Excel export log (file URI, status,
 *   meta-fields, etc).
 * @path /virtualAccount/excelExports/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /**
     * Excel export event log UUID (primary key of
     * virtual_account_excel_exports).
     */
    id: string & tags.Format<"uuid">;

    /**
     * Fields to update in the Excel export log (file URI, status,
     * meta-fields, etc).
     */
    body: IVirtualAccountExcelExports.IUpdate;
  };
  export type Body = IVirtualAccountExcelExports.IUpdate;
  export type Response = IVirtualAccountExcelExports;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/excelExports/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/excelExports/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountExcelExports =>
    typia.random<IVirtualAccountExcelExports>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete an admin Excel export event log (virtual_account_excel_exports table).
 *
 * Deletes an Excel export audit log record from the
 * `virtual_account_excel_exports` table, identified by its UUID. Used rarely,
 * for administrative removal/scrubbing of export histories as per the
 * requirements of compliance, privacy, or offboarding policies. Ensures
 * appropriate permissions on delete, with error handling for non-existent or
 * unauthorized record IDs.
 *
 * Returns a confirmation (could be deleted record, usually confirmation/null on
 * success). All field meanings and behaviors as described in the Prisma schema.
 * Deletion is irreversible and requires full audit log to be written elsewhere,
 * especially for compliance-sensitive records such as data exports.
 *
 * @param props.id Excel export event log UUID (primary key) to delete.
 * @path /virtualAccount/excelExports/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Excel export event log UUID (primary key) to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountExcelExports.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/excelExports/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/excelExports/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountExcelExports.IDeleteResult =>
    typia.random<IVirtualAccountExcelExports.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
