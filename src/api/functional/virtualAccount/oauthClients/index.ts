import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountOAuthClients } from "../../../structures/IVirtualAccountOAuthClients";
import { IPageIVirtualAccountOAuthClients } from "../../../structures/IPageIVirtualAccountOAuthClients";

/**
 * Create a new OAuth2 client registry entry in 'virtual_account_oauth_clients'.
 *
 * This endpoint creates a new OAuth2 client credential entry in
 * 'virtual_account_oauth_clients'.
 *
 * The API expects all required metadata in the request body (client_id,
 * provider_name, integration_type, enabled). Sensitive secrets/tokens are NOT
 * stored in this table and must be handled separately (per security design).
 * After creation, the returned record includes metadata, not secret.
 *
 * Business rules: unique client_id enforced, 'enabled' flag honored, all events
 * audited (see 보안정책/권한관리). Violations (dup client_id) return 409. On success,
 * the created credential's metadata is returned. Applies full privilege checks
 * as relevant to this domain (RBAC: only admins).
 *
 * @param props.body Payload for new OAuth2 client credential record, including
 *   client_id, enabled, provider, integration_type.
 * @path /virtualAccount/oauthClients
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Payload for new OAuth2 client credential record, including client_id,
     * enabled, provider, integration_type.
     */
    body: IVirtualAccountOAuthClients.ICreate;
  };
  export type Body = IVirtualAccountOAuthClients.ICreate;
  export type Response = IVirtualAccountOAuthClients;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/oauthClients",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/oauthClients";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountOAuthClients =>
    typia.random<IVirtualAccountOAuthClients>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/filter/search OAuth2 client registry entries from
 * 'virtual_account_oauth_clients'.
 *
 * This endpoint retrieves a paginated and filterable list of OAuth2 client
 * credentials registered in the 'virtual_account_oauth_clients' table.
 *
 * Core use case: admin dashboard or system operator screens for credential
 * registry management, audit, and rollover. Search parameters allow precise
 * lookup by client_id, provider, status, and integration_type. Returns
 * essential credential metadata, never secrets. Results are paged in accordance
 * with frontend requirements; large result sets are split for performance/UX
 * logic. Designed for RBAC admin use only.
 *
 * Querying this API does not reveal any sensitive material—only identifiers and
 * metadata. If unauthorized or insufficient privileges, the API returns a 403
 * error. Follows all PII/security logging rules in the security spec. Error
 * responses follow OpenAPI best practices.
 *
 * @param props.body Filter and pagination/query options for listing OAuth2
 *   clients (client_id, provider_name, integration_type, enabled, page/size,
 *   sort).
 * @path /virtualAccount/oauthClients
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filter and pagination/query options for listing OAuth2 clients
     * (client_id, provider_name, integration_type, enabled, page/size,
     * sort).
     */
    body: IVirtualAccountOAuthClients.IRequest;
  };
  export type Body = IVirtualAccountOAuthClients.IRequest;
  export type Response = IPageIVirtualAccountOAuthClients;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/oauthClients",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/oauthClients";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountOAuthClients =>
    typia.random<IPageIVirtualAccountOAuthClients>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get detailed info for a single OAuth2 client from
 * 'virtual_account_oauth_clients'.
 *
 * This endpoint fetches the details of a single OAuth2 client record from
 * 'virtual_account_oauth_clients'.
 *
 * Intended for system administrators, credential rotators, or integration
 * maintainers, the core use is to inspect client_id, integration_type,
 * provider_name, enable/disable status, and registration meta. Does not reveal
 * secrets. Rooted in RBAC enforcement—as per security requirements
 * documentation, improper access is forbidden.
 *
 * The operation performs a direct PK lookup using the 'id' parameter. If record
 * exists, its data is returned (fast path). Otherwise, returns 404. All access
 * is logged for compliance. No side effects, and never changes any data.
 * Follows security, audit, and error design outlined in requirements/Prisma
 * schema.
 *
 * @param props.id The PK UUID of the OAuth2 client credential to retrieve.
 * @path /virtualAccount/oauthClients/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** The PK UUID of the OAuth2 client credential to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountOAuthClients;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/oauthClients/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/oauthClients/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountOAuthClients =>
    typia.random<IVirtualAccountOAuthClients>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update the metadata for a specific OAuth2 client in
 * 'virtual_account_oauth_clients'.
 *
 * This endpoint updates an existing OAuth2 client credential metadata in
 * 'virtual_account_oauth_clients' identified by its UUID.
 *
 * Used for credential rollover, enabling/disabling integrations, editing
 * provider or configuration meta. Sensitive tokens are never stored or
 * returned—this API covers metadata fields only. PK constraint on 'id'
 * parameter is enforced by Prisma for strict integrity. Business rules: only
 * enabled admins with RBAC update permission can call this API. Audit log is
 * recorded.
 *
 * If record does not exist (404) or is immutable (locked), errors are returned.
 * On success, the modified credential metadata is returned.
 *
 * @param props.id PK UUID of OAuth2 client credential to update.
 * @param props.body Partial or full update info for OAuth2 client (metadata
 *   fields only).
 * @path /virtualAccount/oauthClients/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** PK UUID of OAuth2 client credential to update. */
    id: string & tags.Format<"uuid">;

    /** Partial or full update info for OAuth2 client (metadata fields only). */
    body: IVirtualAccountOAuthClients.IUpdate;
  };
  export type Body = IVirtualAccountOAuthClients.IUpdate;
  export type Response = IVirtualAccountOAuthClients;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/oauthClients/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/oauthClients/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountOAuthClients =>
    typia.random<IVirtualAccountOAuthClients>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete an OAuth2 client credential registry record by ID from
 * 'virtual_account_oauth_clients'.
 *
 * This endpoint deletes a specific OAuth2 client credential's metadata from
 * 'virtual_account_oauth_clients'.
 *
 * Intended for admin-only use—removes credential registry for a given client
 * app/integration. Typical use cases: de-provisioning, credential rollover,
 * external integration cutover. Deletion is non-recoverable and is always
 * audited as per the security and compliance requirements. Deletes only the
 * metadata row and never includes any secrets or child records in other tables.
 * Fails with 404 if record is not found.
 *
 * Strictly RBAC-governed. Permission or missing resource errors follow OpenAPI
 * error design.
 *
 * @param props.id PK UUID of OAuth2 client credential to delete.
 * @path /virtualAccount/oauthClients/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** PK UUID of OAuth2 client credential to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountOAuthClients.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/oauthClients/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/oauthClients/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountOAuthClients.IDeleteResult =>
    typia.random<IVirtualAccountOAuthClients.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
