import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountCustomer } from "../../../structures/IVirtualAccountCustomer";
import { IPageIVirtualAccountCustomer } from "../../../structures/IPageIVirtualAccountCustomer";

/**
 * Register a new virtual account customer (virtual_account_customers table).
 *
 * Registers a new customer in the system, generating a secure, unique customer
 * record in accordance with the 'virtual_account_customers' schema. Required
 * fields include name, phone, email (all unique and validated), and optional
 * registration data respecting normalization and compliance rules.
 *
 * This endpoint is invoked when new users join the service or are onboarded by
 * an admin. Automatic audit logs are created for the registration, and all
 * input is validated according to KYC and contact uniqueness rules.
 *
 * Security policies enforce that only administrators or public system workflows
 * can invoke this API. Duplicate phone/email are rejected with specific error
 * codes.
 *
 * Business rules dictate that registration date is captured server-side.
 * Related endpoints are GET for listing and PUT/DELETE for modification or
 * removal.
 *
 * On success, the returned customer data reflects the normalized, canonical
 * schema representation.
 *
 * @param props.body Customer details for registration—name, phone, email
 *   required.
 * @path /virtualAccount/customers
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Customer details for registration—name, phone, email required. */
    body: IVirtualAccountCustomer.ICreate;
  };
  export type Body = IVirtualAccountCustomer.ICreate;
  export type Response = IVirtualAccountCustomer;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/customers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/customers";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountCustomer => typia.random<IVirtualAccountCustomer>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List virtual account customers with filtering and pagination
 * (virtual_account_customers table).
 *
 * This endpoint is designed to fetch a paginated and searchable list of
 * customers who are registered in the virtual account system. It references the
 * 'virtual_account_customers' table, which stores key customer information such
 * as name, phone, email, and registration timestamp, as detailed in the Prisma
 * schema.
 *
 * The endpoint supports advanced filtering by customer name, phone number,
 * email, registration period, and deletion state. Pagination and sorting
 * options are provided to enhance admin dashboard usability and facilitate
 * Excel export features, fulfilling dashboard and reporting use-cases.
 *
 * Access to this endpoint is typically restricted to administrator users or
 * higher, as enforced by RBAC and API authentication mechanisms (OAuth2/HMAC).
 * All queries are logged for audit trail, and returned data never includes
 * deleted records unless specifically requested by filter.
 *
 * Validation rules include: string filter fields must be valid, dates in ISO,
 * and filters do not expose physical deletion timestamps. Error handling is
 * robust, responding with well-formed error objects for permission or
 * validation failures.
 *
 * Related API operations include: GET /virtualAccount/customers/{id} for
 * detail, POST /virtualAccount/customers for creation, and PUT/DELETE for
 * update/removal.
 *
 * Returned data is always anonymized where required for compliance, and
 * response includes a total count for UI pagination controls. This endpoint
 * underpins the main customer search view in the admin console.
 *
 * @param props.body Query parameters for filtering, searching, and pagination
 *   when listing virtual account customers.
 * @path /virtualAccount/customers
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Query parameters for filtering, searching, and pagination when
     * listing virtual account customers.
     */
    body: IVirtualAccountCustomer.IRequest;
  };
  export type Body = IVirtualAccountCustomer.IRequest;
  export type Response = IPageIVirtualAccountCustomer;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/customers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/customers";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountCustomer =>
    typia.random<IPageIVirtualAccountCustomer>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetch detailed information for a specific virtual account customer
 * (virtual_account_customers table).
 *
 * Retrieves complete details for a single customer from the
 * 'virtual_account_customers' table, including their name, contact info,
 * registration date, and any soft deletion state.
 *
 * This endpoint requires the customer ID as a path parameter. Access is
 * generally limited to authenticated administrators with appropriate
 * permissions (see RBAC policy). Audit logs are generated for every access to
 * customer detail.
 *
 * If the specified customer does not exist, or access is not authorized, a
 * clear error code and message are returned.
 *
 * This endpoint is typically used in conjunction with the customer search/list
 * endpoint, and is displayed as the details pane or page on the admin
 * dashboard.
 *
 * No sensitive information, such as passwords, is included in the response.
 * Sensitive fields are masked per compliance needs. All responses are
 * structured according to the 'IVirtualAccountCustomer' API schema.
 *
 * @param props.id ID of the virtual account customer to retrieve.
 * @path /virtualAccount/customers/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** ID of the virtual account customer to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountCustomer;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/customers/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/customers/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountCustomer => typia.random<IVirtualAccountCustomer>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a specific virtual account customer's profile
 * (virtual_account_customers table).
 *
 * Enables authorized administrators to update the profile of a customer based
 * on their unique ID. Modifiable fields include name, phone number, and email,
 * subject to uniqueness validation. Certain fields such as registration date
 * and ID are immutable.
 *
 * All modifications trigger audit log entries and are regulated by RBAC
 * permissions and API authentication. Validation errors (duplicate email/phone,
 * invalid formats) are returned with descriptive error codes.
 *
 * This endpoint is cross-referenced by the list/detail endpoints for customers.
 * Upon success, returns the updated customer object according to the canonical
 * schema.
 *
 * Soft deletion (setting deleted_at) is not handled by this endpoint; use
 * DELETE instead. This operation is intended for admin use only.
 *
 * @param props.id Unique identifier for the customer to update.
 * @param props.body Profile fields to update (name, phone, email); registration
 *   date and ID not modifiable.
 * @path /virtualAccount/customers/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier for the customer to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Profile fields to update (name, phone, email); registration date and
     * ID not modifiable.
     */
    body: IVirtualAccountCustomer.IUpdate;
  };
  export type Body = IVirtualAccountCustomer.IUpdate;
  export type Response = IVirtualAccountCustomer;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/customers/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/customers/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountCustomer => typia.random<IVirtualAccountCustomer>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete (deactivate) a virtual account customer by ID
 * (virtual_account_customers table).
 *
 * This endpoint marks a customer record as deleted (sets deleted_at). It does
 * not physically remove the record, in compliance with audit, KYC, and
 * retention requirements. Only administrators with the appropriate privilege
 * may use this API.
 *
 * The customer to be deleted is identified by the unique ID path parameter.
 * Deletion attempts are validated for existence, current state (e.g., not
 * already deleted), and authorization.
 *
 * All deletion actions are logged for audit/forensics. Related activity may
 * include cascading notifications or disabling attached virtual accounts per
 * policy.
 *
 * This endpoint is intended exclusively for backend/admin use. Related
 * endpoints: GET for recovery/view, PATCH for filtering, PUT for profile
 * update.
 *
 * On success, returns a confirmation or the updated customer record, with
 * deleted_at populated.
 *
 * @param props.id Unique identifier of the customer to delete.
 * @path /virtualAccount/customers/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the customer to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountCustomer;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/customers/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/customers/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountCustomer => typia.random<IVirtualAccountCustomer>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
