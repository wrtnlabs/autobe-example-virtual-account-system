import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountVirtualAccount } from "../../../structures/IVirtualAccountVirtualAccount";
import { IPageIVirtualAccountVirtualAccount } from "../../../structures/IPageIVirtualAccountVirtualAccount";

/**
 * Create a new virtual account entry in the `virtual_account_virtual_accounts`
 * table.
 *
 * This endpoint lets an administrator (or automated backend process) create a
 * new virtual account for a customer. Requires all atomic, non-derived fields
 * as per the schema: customer ID, bank, PG provider, account number, status,
 * holder, expiry, etc. Ensures referential integrity to valid customers, banks,
 * and PGs; rejects inserts for missing/invalid FKs.
 *
 * Security: Only authorized admins may issue new accounts, via RBAC. Uniqueness
 * for (account number + bank + PG) is strictly enforced. The created account
 * row will be used for downstream deposit/matching/notification functionality.
 *
 * Upon success, returns the new virtual account record. Violations in unique or
 * referential constraints generate informative REST errors. Related endpoints
 * support update, delete, and query actions.
 *
 * @param props.body Data for the new virtual account, including references to
 *   customer, bank, PG, and settings.
 * @path /virtualAccount/virtualAccounts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Data for the new virtual account, including references to customer,
     * bank, PG, and settings.
     */
    body: IVirtualAccountVirtualAccount.ICreate;
  };
  export type Body = IVirtualAccountVirtualAccount.ICreate;
  export type Response = IVirtualAccountVirtualAccount;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/virtualAccounts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/virtualAccounts";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountVirtualAccount =>
    typia.random<IVirtualAccountVirtualAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List or search virtual accounts in the `virtual_account_virtual_accounts`
 * table with paging/filter/sort support.
 *
 * This endpoint returns a paginated, filterable, and sortable list of virtual
 * accounts from the `virtual_account_virtual_accounts` table. Filtering can
 * include criteria such as customer ID, status, bank or PG, account number,
 * expiration dates, etc. Sorting options support admin dashboard/search
 * requirements.
 *
 * Security is enforced: only authenticated admins or super admins may access
 * the list. Root search fields are atomic and map directly to the schema
 * columns; non-derived only. Pagination follows standard conventions (page
 * number/size). Errors are returned for invalid queries or authentication
 * failures.
 *
 * Used for dashboard screens, statistics, and operational monitoring. Related
 * endpoints exist for detail viewing, creation, updates, and deletion.
 *
 * @param props.body Search, filter, and paging information for virtual account
 *   queries.
 * @path /virtualAccount/virtualAccounts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search, filter, and paging information for virtual account queries. */
    body: IVirtualAccountVirtualAccount.IRequest;
  };
  export type Body = IVirtualAccountVirtualAccount.IRequest;
  export type Response = IPageIVirtualAccountVirtualAccount;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/virtualAccounts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/virtualAccounts";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountVirtualAccount =>
    typia.random<IPageIVirtualAccountVirtualAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetch a specific virtual account from the `virtual_account_virtual_accounts`
 * table by ID.
 *
 * This endpoint fetches a single virtual account by its unique ID. Response
 * data includes all fields from the table, such as account number, customer,
 * bank, PG provider, status, and expiry. Related entities may be expanded as
 * per needs (bank, customer, PG provider info) if applicable.
 *
 * Secured by RBAC: only privileged admins can view full virtual account detail.
 * 404 is returned if the account is not found. All data is atomic per schema
 * and restricted to non-derived columns.
 *
 * This operation serves dashboard inspection, troubleshooting, and tracking use
 * cases. Errors use standard REST semantics for not found and unauthorized.
 *
 * Related endpoints cover list/retrieve, create, update, and delete actions.
 *
 * @param props.id Unique identifier (UUID) of the virtual account.
 * @path /virtualAccount/virtualAccounts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier (UUID) of the virtual account. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountVirtualAccount;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/virtualAccounts/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/virtualAccounts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountVirtualAccount =>
    typia.random<IVirtualAccountVirtualAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing virtual account entry in the
 * `virtual_account_virtual_accounts` table by ID.
 *
 * This endpoint enables administrators to update fields in a virtual account
 * record, identified by unique ID. Fields like status, expiry, and holder name
 * may be edited, subject to business rules. Primary keys and immutable system
 * fields may not be changed. Uniqueness of (account_number, bank, PG) is
 * strictly enforced. Only updatable fields as per the schema/editor design can
 * be supplied.
 *
 * Referential and security constraints are always validated. 404 is returned if
 * the row is not found. The operation is only allowed for privileged admins
 * (RBAC policy).
 *
 * Typical use: fixing account expiry dates, status updates, or changing holder
 * name for correction. Input validation, constraints, and business logic are
 * all applied per schema documentation. Error handling for authorization, not
 * found, and constraint violations is robust.
 *
 * Related endpoints: create, delete, get, list.
 *
 * @param props.id Unique identifier (UUID) of the virtual account.
 * @param props.body Fields to update for the virtual account.
 * @path /virtualAccount/virtualAccounts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier (UUID) of the virtual account. */
    id: string & tags.Format<"uuid">;

    /** Fields to update for the virtual account. */
    body: IVirtualAccountVirtualAccount.IUpdate;
  };
  export type Body = IVirtualAccountVirtualAccount.IUpdate;
  export type Response = IVirtualAccountVirtualAccount;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/virtualAccounts/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/virtualAccounts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountVirtualAccount =>
    typia.random<IVirtualAccountVirtualAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a virtual account from the `virtual_account_virtual_accounts` table by
 * ID.
 *
 * This endpoint allows an authorized admin to delete a virtual account from the
 * system by its unique ID. Deletion is subject to eligibility—referential
 * integrity and business rules (e.g., cannot delete accounts attached to
 * deposits or active business processes). Foreign key constraints ensure no
 * cascading loss of related required data.
 *
 * Security: Only privileged admins may perform deletions. If the account does
 * not exist, a 404 is returned. If forbidden by reference rules, a 409 Conflict
 * is returned.
 *
 * Successful deletions return no content (HTTP 204).
 *
 * Related endpoints include creation, update, get, and list operations on
 * virtual accounts.
 *
 * @param props.id Unique identifier (UUID) of the virtual account.
 * @path /virtualAccount/virtualAccounts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier (UUID) of the virtual account. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/virtualAccounts/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/virtualAccounts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
