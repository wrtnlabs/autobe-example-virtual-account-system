import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVirtualAccountAuditLog } from "../../../structures/IVirtualAccountAuditLog";
import { IPageIVirtualAccountAuditLog } from "../../../structures/IPageIVirtualAccountAuditLog";

/**
 * Create a new audit log (virtual_account_audit_logs).
 *
 * Creates a new audit log entry in virtual_account_audit_logs to record an
 * administrative, user, or system action. This is used extensively for
 * security, compliance, and traceability (see requirements and
 * 07_virtual_account_security.md). The request body must provide all necessary
 * fields such as actor_id/type, event_type, target_type/id, description, and
 * occurred_at.
 *
 * Successful creation returns the created audit log object. Errors (validation,
 * lack of permission) are reported as 422/403. Only authorized system
 * components and admin users can invoke this endpoint. All write actions are
 * themselves logged to ensure complete traceability. Related endpoints:
 * PATCH/GET/PUT/DELETE for listing and updating audit logs.
 *
 * @param props.body Audit log creation payload
 * @path /virtualAccount/auditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Audit log creation payload */
    body: IVirtualAccountAuditLog.ICreate;
  };
  export type Body = IVirtualAccountAuditLog.ICreate;
  export type Response = IVirtualAccountAuditLog;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/auditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/auditLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountAuditLog => typia.random<IVirtualAccountAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve filtered, paginated list of audit logs (virtual_account_audit_logs).
 *
 * Retrieves a list of audit logs from the virtual_account_audit_logs table,
 * with support for pagination, keyword/date filtering, actor/target filtering,
 * and sorting. The audit logs table implements system-wide action tracking for
 * admin, customer, and system actions (see requirements and
 * 07_virtual_account_security.md). This endpoint is essential for audit,
 * compliance, and dashboard analysis.
 *
 * The endpoint accepts a JSON request body specifying filter criteria: actor
 * ID/type, event type, date ranges, target type, and keyword search. Paginated
 * response includes relevant logs (with actor, event, target, timestamp, and
 * description). Access restricted to authorized admin/compliance roles. Results
 * may be sorted by date or event type. All access to this endpoint is itself
 * audited.
 *
 * The response is a page of audit logs with pagination metadata. 403 returned
 * for unauthorized access. 422 for invalid filter parameters. Related
 * endpoints: GET/PUT/DELETE single log, and PATCH with different filters.
 *
 * @param props.body Filter and search criteria for paginated audit log
 *   retrieval
 * @path /virtualAccount/auditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filter and search criteria for paginated audit log retrieval */
    body: IVirtualAccountAuditLog.IRequest;
  };
  export type Body = IVirtualAccountAuditLog.IRequest;
  export type Response = IPageIVirtualAccountAuditLog;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/auditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/auditLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIVirtualAccountAuditLog =>
    typia.random<IPageIVirtualAccountAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a specific audit log by ID (virtual_account_audit_logs).
 *
 * Fetches a single audit log record from the virtual_account_audit_logs table
 * using the provided audit log ID. The audit log entity is used for tracking
 * all sensitive actions and changes in the system, as required for compliance
 * and forensic audit (see requirements and 07_virtual_account_security.md).
 *
 * Path parameter 'id' is required and must match the audit log primary key. The
 * response includes all properties of the audit log entity (actor, event type,
 * timestamp, description, etc). Endpoint is access controlled for
 * admin/compliance/audit roles. 404 is returned if no matching log is found.
 * 403 returned for insufficient permissions. Related endpoints: PATCH for list,
 * PUT/DELETE for the same log.
 *
 * @param props.id Audit log entry ID to retrieve
 * @path /virtualAccount/auditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Audit log entry ID to retrieve */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/auditLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/auditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountAuditLog => typia.random<IVirtualAccountAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing audit log entry by ID (virtual_account_audit_logs).
 *
 * Updates a single audit log entry in the virtual_account_audit_logs table,
 * identified by its unique ID (path parameter). The payload allows updating
 * certain mutable properties (such as description, result, or meta fields as
 * permitted by policy), but primary audit identifiers (actor, event_type,
 * occurred_at) must remain immutable for compliance integrity. This endpoint is
 * admin-only and subject to careful use (all updates must themselves be
 * logged).
 *
 * If entry not found, returns 404. If update not permitted, returns 403.
 * Successfully updating returns the new audit log object. Related endpoints:
 * PATCH for list, GET/DELETE for the same log.
 *
 * @param props.id Audit log entry ID to update
 * @param props.body Update payload for audit log entry
 * @path /virtualAccount/auditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Audit log entry ID to update */
    id: string & tags.Format<"uuid">;

    /** Update payload for audit log entry */
    body: IVirtualAccountAuditLog.IUpdate;
  };
  export type Body = IVirtualAccountAuditLog.IUpdate;
  export type Response = IVirtualAccountAuditLog;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/auditLogs/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/auditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountAuditLog => typia.random<IVirtualAccountAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete an audit log entry by ID (virtual_account_audit_logs).
 *
 * Deletes a single audit log entry from virtual_account_audit_logs, identified
 * by its unique ID. This entity is used for system-wide action/audit-trail as
 * required by requirements and 07_virtual_account_security.md. Only authorized
 * admin or compliance users may delete logs; all deletions are themselves audit
 * logged.
 *
 * Log deletion is permanent and should never cascade to other entities. If the
 * log does not exist, a 404 is returned. A successful deletion returns HTTP 204
 * (no content). Permission errors return 403. Related endpoints: PATCH/GET/PUT
 * for the same log, and audit/admin action logging.
 *
 * @param props.id Audit log entry ID to delete
 * @path /virtualAccount/auditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Audit log entry ID to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/auditLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/auditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
