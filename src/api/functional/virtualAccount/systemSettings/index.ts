import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { virtual_account_system_settings } from "../../../structures/virtual_account_system_settings";
import { IPagevirtual_account_system_settings } from "../../../structures/IPagevirtual_account_system_settings";
import { IVirtualAccountSystemSettings } from "../../../structures/IVirtualAccountSystemSettings";

/**
 * Create a new system setting (virtual_account_system_settings table).
 *
 * This operation allows a privileged admin or super admin to create a new
 * system configuration or setting. The request body specifies the domain
 * (feature/area), unique setting_key, value, and description. Validation rules
 * enforce uniqueness of (domain, setting_key) per schema, and type/value
 * compliance.
 *
 * Permissions: RBAC restricted to super admin or allowed admin users only. The
 * action is fully logged for security tracking purposes. On success, responds
 * with the created setting entry. Returns 422 for validation, 403 for
 * forbidden, 409 for conflict, 500 for system errors. Use together with PATCH
 * (list), GET (detail), PUT (update), and DELETE (if allowed).
 *
 * @param props.body System setting creation info (domain, key, value,
 *   description, etc)
 * @path /virtualAccount/systemSettings
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** System setting creation info (domain, key, value, description, etc) */
    body: virtual_account_system_settings.ICreate;
  };
  export type Body = virtual_account_system_settings.ICreate;
  export type Response = virtual_account_system_settings;

  export const METADATA = {
    method: "POST",
    path: "/virtualAccount/systemSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/systemSettings";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): virtual_account_system_settings =>
    typia.random<virtual_account_system_settings>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/filter system settings (virtual_account_system_settings table).
 *
 * This operation lists and filters system settings, supporting filtered queries
 * based on domain, setting_key, value, or description. Used in the admin
 * dashboard for config retrieval, security review, or export. The request body
 * specifies search and pagination/sorting info.
 *
 * RBAC restricts to admin and super admin only. Results may be exported (linked
 * Excel export API). All query activity is tracked in logs for compliance. Use
 * GET for single record detail, POST for creation, PUT for updates.
 *
 * @param props.body Search and pagination info for system settings list
 * @path /virtualAccount/systemSettings
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search and pagination info for system settings list */
    body: virtual_account_system_settings.IRequest;
  };
  export type Body = virtual_account_system_settings.IRequest;
  export type Response = IPagevirtual_account_system_settings;

  export const METADATA = {
    method: "PATCH",
    path: "/virtualAccount/systemSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/virtualAccount/systemSettings";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPagevirtual_account_system_settings =>
    typia.random<IPagevirtual_account_system_settings>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a system settings record by ID (virtual_account_system_settings table).
 *
 * Returns a single system settings record, given its ID. Restricted to admins
 * and super admins. Returns all system setting columns (domain, setting_key,
 * value, description, etc). Logs query for audit purposes. 404 if not found,
 * 403 on permission, 500 for internal errors.
 *
 * Use PATCH for lists/query, POST for creation, PUT for update, DELETE for
 * deletion if enabled by policy.
 *
 * @param props.id System setting primary key (UUID)
 * @path /virtualAccount/systemSettings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** System setting primary key (UUID) */
    id: string & tags.Format<"uuid">;
  };
  export type Response = virtual_account_system_settings;

  export const METADATA = {
    method: "GET",
    path: "/virtualAccount/systemSettings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/systemSettings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): virtual_account_system_settings =>
    typia.random<virtual_account_system_settings>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a system setting by ID (virtual_account_system_settings table).
 *
 * Updates an existing system setting entry identified by its UUID. Permitted
 * updates: value, description, possibly other descriptive columns. The (domain,
 * setting_key) pair is not modifiable. Only allowed for super admins or allowed
 * configuration admins under RBAC. Every update is fully logged for
 * replay/investigation/audit purposes.
 *
 * Validation ensures type, constraint (not already deleted/disabled), and all
 * reference checks. Returns updated record on success, 404 for not found, 409
 * on constraint violation, 403 for RBAC, or 422 for request errors. Use
 * together with PATCH (list), GET (detail), POST (create), and DELETE (if
 * permitted).
 *
 * @param props.id Target system setting record ID (UUID)
 * @param props.body Update info for system setting (new value, description,
 *   etc)
 * @path /virtualAccount/systemSettings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target system setting record ID (UUID) */
    id: string & tags.Format<"uuid">;

    /** Update info for system setting (new value, description, etc) */
    body: virtual_account_system_settings.IUpdate;
  };
  export type Body = virtual_account_system_settings.IUpdate;
  export type Response = virtual_account_system_settings;

  export const METADATA = {
    method: "PUT",
    path: "/virtualAccount/systemSettings/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/virtualAccount/systemSettings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): virtual_account_system_settings =>
    typia.random<virtual_account_system_settings>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a system settings record by its ID from
 * 'virtual_account_system_settings' table.
 *
 * This endpoint deletes a specific system configuration record from
 * 'virtual_account_system_settings'.
 *
 * The primary purpose is to allow administrators to remove obsolete, revoked,
 * or incorrect system settings. It enforces strict privilege requirements—only
 * system, infra, or security admins can call this API. Deletion is tracked in
 * audit logs as per security policy requirements in the requirements reports
 * (see 권한·감사·보안).
 *
 * Relationally, this operates exclusively on the configuration row identified
 * by 'id' PK in the table. There are no cascading deletes to other
 * entities—child references (if any) are not deleted. Business logic ensures
 * non-recoverable operations are logged. Deletion requests are verified for
 * orphan creation (should not break config dependencies).
 *
 * If an invalid/nonexistent ID is provided, the API returns 404. If deleted, no
 * further queries for this 'id' should succeed. On error, a permission or
 * internal error code is returned as specified in the OpenAPI standard for this
 * service domain.
 *
 * @param props.id Primary key ID of the system settings record to delete.
 * @path /virtualAccount/systemSettings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Primary key ID of the system settings record to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVirtualAccountSystemSettings.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/virtualAccount/systemSettings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/virtualAccount/systemSettings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVirtualAccountSystemSettings.IDeleteResult =>
    typia.random<IVirtualAccountSystemSettings.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
